

## Практическая часть

### Часть 1. Мониторинг активности
**Выполненные задачи:**   
1. В новой базе данных `lr06_db` создал таблицу `monitor_test (id INT)`. Вставил несколько строк, затем удалил все. Изучил статистику обращений к таблице в `pg_stat_all_tables` (`n_tup_ins`, `n_tup_del`, `n_live_tup`, `n_dead_tup`). Выполнил `VACUUM`. Вставки и удаления отражаются в `n_tup_ins` и `n_tup_del` соответственно. После `DELETE` растёт `n_dead_tup`. `VACUUM` уменьшает «мёртвые» строки (`n_dead_tup`) и увеличивает `vacuum_count`.

2. Создал ситуацию взаимоблокировки двух транзакций. Изучил, какая информация записывается в журнал сообщений сервера при обнаружении взаимоблокировки.

3. Установил и настроил расширение `pg_stat_statements`. Выполнил несколько произвольных запросов. Изучил информацию в представлении `pg_stat_statements` (топ запросов, время выполнения и т.д.).

**Команды:**

**Задача 1:**
```sql
CREATE DATABASE lab06_db;
\c lab06_db
SELECT pg_stat_reset();
CREATE TABLE monitor_test(id INT PRIMARY KEY);
INSERT INTO monitor_test VALUES (1),(2),(3),(4);
DELETE FROM monitor_test;
SELECT relname, n_tup_ins, n_tup_del, n_live_tup, n_dead_tup
FROM pg_stat_all_tables
WHERE relname='monitor_test';
VACUUM monitor_test;
SELECT relname, n_tup_ins, n_tup_del, n_live_tup, n_dead_tup, vacuum_count
FROM pg_stat_all_tables
WHERE relname='monitor_test';
```

**Задача 2:**
```sql
-- Сеанс 1
CREATE TABLE dead_demo(id INT PRIMARY KEY, val INT);
INSERT INTO dead_demo VALUES (1,10),(2,20);
BEGIN;
UPDATE dead_demo SET val=11 WHERE id=1;
```
```sql
-- Сеанс 2
BEGIN;
UPDATE dead_demo SET val=21 WHERE id=2;
```
```sql
-- Сеанс 1
UPDATE dead_demo SET val=12 WHERE id=2;
```
```sql
-- Сеанс 2
UPDATE dead_demo SET val=22 WHERE id=1; 
ROLLBACK;
```
```sql
-- Сеанс 1
ROLLBACK;
```
```bash
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log
```

**Задача 3:**
```bash
    sudo apt-get update
    sudo apt-get install postgresql-contrib
    sudo systemctl restart postgresql
```
```sql
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';
SELECT pg_reload_conf();
CREATE EXTENSION pg_stat_statements;
SELECT count(*) FROM dead_demo;
SELECT * FROM dead_demo WHERE id=1;
SELECT * FROM dead_demo WHERE id=2;
INSERT INTO dead_demo VALUES (9,32),(10,45);
SELECT query, calls, total_plan_time, total_exec_time, 
mean_plan_time, mean_exec_time, rows
FROM pg_stat_statements;
```

**Фрагменты вывода:** 

**Задача 1:**
```text
 pg_stat_reset 
---------------
 
(1 row)

CREATE TABLE

INSERT 0 4

DELETE 4

   relname    | n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
--------------+-----------+-----------+------------+------------
 monitor_test |         4 |         4 |          0 |          4
(1 row)

VACUUM

   relname    | n_tup_ins | n_tup_del | n_live_tup | n_dead_tup | vacuum_count 
--------------+-----------+-----------+------------+------------+--------------
 monitor_test |         4 |         4 |          0 |          0 |            1
(1 row)
```

**Задача 2:**
```text
-- Сеанс 1
CREATE TABLE
INSERT 0 2
BEGIN
UPDATE 1
```
```text
-- Сеанс 2
BEGIN
UPDATE 1
```
```text
-- Сеанс 1
UPDATE 1
```
```text
-- Сеанс 2
ERROR:  deadlock detected
DETAIL:  Process 97289 waits for ShareLock on transaction 366333; blocked by process 94625.
Process 94625 waits for ShareLock on transaction 366334; blocked by process 97289.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "dead_demo"

ROLLBACK
```
```text
-- Сеанс 1
ROLLBACK
```
```text
2025-10-09 13:20:42.866 MSK [97289] student@lab06_db ERROR:  deadlock detected
2025-10-09 13:20:42.866 MSK [97289] student@lab06_db DETAIL:  Process 97289 waits for ShareLock on transaction 366333; blocked by process 94625.
	Process 94625 waits for ShareLock on transaction 366334; blocked by process 97289.
	Process 97289: UPDATE dead_demo SET val=22 WHERE id=1;
	Process 94625: UPDATE dead_demo SET val=12 WHERE id=2;
```

**Задача 3:**
```text
ALTER SYSTEM

 pg_reload_conf 
----------------
 t
(1 row)

CREATE EXTENSION

 count 
-------
     8
(1 row)

 id | val 
----+-----
  1 |  10
(1 row)

 id | val 
----+-----
  2 |  20
(1 row)

INSERT 0 2
```
```text
 INSERT INTO dead_demo VALUES ($1,$2),($3,$4)                     |     1 |               0 |            0.042891 |              0 |            0.042891 |    2
 SELECT calls, total_plan_time, total_exec_time,                 +|     1 |               0 | 0.10167699999999999 |              0 | 0.10167699999999999 |    9
 mean_plan_time, mean_exec_time, rows, query                     +|       |                 |                     |                |                     | 
 FROM pg_stat_statements                                          |       |                 |                     |                |                     | 
 SELECT * FROM dead_demo WHERE id=$1                              |     2 |               0 |            0.031036 |              0 |            0.015518 |    2
 SELECT query, calls                                             +|     1 |               0 | 0.08881399999999999 |              0 | 0.08881399999999999 |    7
         FROM pg_stat_statements                                  |       |                 |                     |                |                     | 
 SELECT pg_reload_conf()                                          |     1 |               0 |            0.060778 |              0 |            0.060778 |    1
 SHOW shared_preload_libraries                                    |     1 |               0 |            0.004164 |              0 |            0.004164 |    0
 SELECT * FROM pg_stat_statements                                 |     3 |               0 |            0.437348 |              0 | 0.14578266666666667 |   21
 SELECT count(*) FROM dead_demo                                   |     1 |               0 |            0.064402 |              0 |            0.064402 |    1
 SELECT * FROM pg_stat_statements LIMIT $1                        |     1 |               0 |            0.125855 |              0 |            0.125855 |    8
 ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements' |     1 |               0 |            7.280041 |              0 |            7.280041 |    0
(10 rows)
```

---

### Часть 2. Блокировки объектов
**Выполненные задачи:**   
1.	На уровне изоляции `Read Committed` прочитал одну строку таблицы по первичному ключу. Изучил удерживаемые блокировки в `pg_locks`. `relation | AccessShareLock | lock_obj` — обычная блокировка таблицы при SELECT, чтобы защитить от DDL (`DROP/TRUNCATE/REWRITE`). `relation | AccessShareLock | lock_obj_pkey` — та же лёгкая блокировка на используемом индексе (PK). `virtualxid | ExclusiveLock` — служебная «своя виртуальная транзакция», есть у каждого сеанса. Остальные `AccessShareLock` на `pg_stat_activity`, `pg_locks`, `pg_authid_*`, `pg_database_*` — это «шум», который появляется из-за просмотра блокировки из того же сеанса: сам запрос к `pg_locks/pg_stat_activity` читает системные каталоги и берёт на них `AccessShareLock`. Пустые `wait_event_type/wait_event` означают, что ожиданий нет.

2.	Воспроизвёл ситуацию автоматического повышения уровня предикатных блокировок при чтении строк по индексу. Показал, что это может привести к ложной ошибке сериализации.

3.	Настроил запись в журнал сообщений о ожиданиях блокировок > 100 мс (`log_lock_waits = on`, `deadlock_timeout = 100ms`). Создал ситуацию длительного ожидания блокировки. Убедися, что сообщение появилось в логе.

**Команды:**

**Задача 1:**
```sql
CREATE TABLE lock_obj(id INT PRIMARY KEY, v INT);
INSERT INTO lock_obj SELECT g, g FROM generate_series(1,10) g;
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM lock_obj WHERE id=1;
SELECT l.pid, l.locktype, l.mode, l.granted, l.relation::regclass AS rel, a.wait_event_type, a.wait_event, a.state
FROM pg_locks l
JOIN pg_stat_activity a USING (pid)
WHERE a.pid = pg_backend_pid();
COMMIT;
```

**Задача 2:**
```sql
-- Сеанс 1
CREATE TABLE pred_demo(id INT PRIMARY KEY, v INT);
INSERT INTO pred_demo SELECT g, g FROM generate_series(1,500) g;
CREATE INDEX ON pred_demo(v);
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT count(*) FROM pred_demo WHERE v BETWEEN 100 AND 400;
INSERT INTO pred_demo VALUES (2000, 200);
```
```sql
-- Сеанс 2
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT count(*) FROM pred_demo WHERE v BETWEEN 100 AND 400;
INSERT INTO pred_demo VALUES (2001, 200);
COMMIT;
```
```sql
-- Сеанс 1
COMMIT;
```

**Задача 3:**
```sql
-- Сеанс 1
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = '100ms';
SELECT pg_reload_conf();
BEGIN;
UPDATE lock_obj SET v = v+1 WHERE id=1;
```
```sql
-- Сеанс 2
BEGIN;
UPDATE lock_obj SET v = v+1 WHERE id=1;
```
```sql
ROLLBACK;
```
```bash
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log
```


**Фрагменты вывода:** 

**Задача 1:**
```text
CREATE TABLE

INSERT 0 10

BEGIN

 id | v 
----+---
  1 | 1
(1 row)


  pid   |  locktype  |      mode       | granted |            rel            | wait_event_type | wait_event | state  
--------+------------+-----------------+---------+---------------------------+-----------------+------------+--------
 104958 | relation   | AccessShareLock | t       | pg_stat_activity          |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_locks                  |                 |            | active
 104958 | relation   | AccessShareLock | t       | lock_obj_pkey             |                 |            | active
 104958 | relation   | AccessShareLock | t       | lock_obj                  |                 |            | active
 104958 | virtualxid | ExclusiveLock   | t       |                           |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_authid_oid_index       |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_database_oid_index     |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_authid_rolname_index   |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_database_datname_index |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_database               |                 |            | active
 104958 | relation   | AccessShareLock | t       | pg_authid                 |                 |            | active
(11 rows)

COMMIT
```

**Задача 2:**
```text
-- Сеанс 1
CREATE TABLE

INSERT 0 500

CREATE INDEX

BEGIN

SET

 count 
-------
   301
(1 row)

INSERT 0 1
```
```text
-- Сеанс 2
BEGIN

SET

 count 
-------
   301
(1 row)

INSERT 0 1

COMMIT
```
```text
-- Сеанс 1
ERROR:  could not serialize access due to read/write dependencies among transactions
DETAIL:  Reason code: Canceled on identification as a pivot, during commit attempt.
HINT:  The transaction might succeed if retried.
```

**Задача 3:**
```text
-- Сеанс 1
ALTER SYSTEM
ALTER SYSTEM
 pg_reload_conf 
----------------
 t
(1 row)

BEGIN
UPDATE 1
```
```text
-- Сеанс 2
BEGIN
```
```text
-- Сеанс 1
ROLLBACK
```
```text
2025-10-09 17:05:59.839 MSK [141471] student@lab06_db LOG:  process 141471 acquired ShareLock on transaction 366374 after 310068.379 ms
2025-10-09 17:05:59.839 MSK [141471] student@lab06_db CONTEXT:  while updating tuple (0,1) in relation "lock_obj"
2025-10-09 17:05:59.839 MSK [141471] student@lab06_db STATEMENT:  UPDATE lock_obj SET v = v+1 WHERE id=1;
```
---

### Часть 3. Блокировки строк
**Выполненные задачи:**   
1.	Смоделировал ситуацию обновления одной и той же строки тремя командами `UPDATE` в разных сеансах. Изучил возникшие блокировки в `pg_locks`. Имеется три pid блокировок: 

- 104958 

`transactionid | ExclusiveLock | t | 366378` — держит свою транзакцию.
`AccessShareLock` на системных каталогах — это «шум».
На таблицу `row_demo — RowExclusiveLock`.

- 141471 — «и блокируется, и блокирует»:

`transactionid | ShareLock | f | 366378` — ждёт завершения транзакции 104958 (`ShareLock` на ID 366378 не выдан).
`tuple | ExclusiveLock | t | row_demo page 0 tuple 1` — держит строковую блокировку той самой строки (id=1).
`transactionid | ExclusiveLock | t | 366375` и `RowExclusiveLock` на `row_demo`.

- 169532

`tuple | ExclusiveLock | f | row_demo page 0 tuple 1` — пытается взять строковую блокировку на ту же строку, ждёт 141471.
`transactionid | ExclusiveLock | t | 366379` и `RowExclusiveLock` — его «собственные» служебные.

2.  Воспроизвёл взаимоблокировку трех транзакций. Проанализировал журнал сообщений сервера. 104958 пытается обновить строку (`page 0, tuple 2`) таблицы row_demo и ждёт завершения транзакции с XID 366393, которую держит 169532. Это ребро ожидания 104958 -> 169532 по строке id≈2. 169532 обновляет (0,3) и ждёт XID 366394, который держит 141471. Ребро 169532 -> 141471 (строка id≈3) 141471 ждёт 366392 и отправляет deadlock.

3.	Попытался воспроизвести ситуацию, когда две транзакции, выполняющие по одному `UPDATE` на одной таблице, взаимоблокируются. Не получилось. При одном `UPDATE` в каждой транзакции взаимоблокировка невозможна — нет цикла ожиданий, вторая транзакция лишь ждёт первую. Для deadlock нужно минимум «перекрёстное» ожидание (например, по двум строкам в разном порядке)

**Команды:**

**Задача 1:**
```sql
-- Сеанс 1
-- Снова оставь курсор A висеть на странице
BEGIN;
DECLARE c2 CURSOR FOR SELECT * FROM pin_demo ORDER BY id;
FETCH 1 FROM c2;

-- Сеанс B:
VACUUM (VERBOSE, FREEZE) pin_demo;

-- Мониторим ожидание:
SELECT pid, wait_event_type, wait_event, query
FROM pg_stat_activity
WHERE query ILIKE 'vacuum%';

```
```sql
-- Сеанс 2
BEGIN;
UPDATE row_demo SET v=v+1 WHERE id=1;     
```
```sql
-- Сеанс 3
BEGIN;
UPDATE row_demo SET v=v+1 WHERE id=1;     
```
```sql
-- Сеанс 1
SELECT l.pid, l.locktype, l.mode, l.granted, l.relation::regclass AS rel, l.transactionid, l.page, l.tuple
FROM pg_locks l
WHERE l.pid IN (
  SELECT pid FROM pg_stat_activity WHERE datname='lab06_db'
)
ORDER BY l.granted, l.locktype, l.mode;
```

**Задача 2:**
```sql
-- Сеанс 1
TRUNCATE row_demo;
INSERT INTO row_demo VALUES (1,100),(2,200),(3,300);
BEGIN;
UPDATE row_demo SET v = v+1 WHERE id = 1; 
```
```sql
-- Сеанс 2
BEGIN;
UPDATE row_demo SET v = v+1 WHERE id = 2;  
```
```sql
-- Сеанс 3
BEGIN;
UPDATE row_demo SET v = v+1 WHERE id = 3;  
```
```sql
-- Сеанс 1
UPDATE row_demo SET v = v+1 WHERE id = 2;

```
```sql
-- Сеанс 2
UPDATE row_demo SET v = v+1 WHERE id = 3;  
```
```sql
-- Сеанс 3
UPDATE row_demo SET v = v+1 WHERE id = 1; 
```
```bash
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log
```

**Задача 3:**
```sql
-- Сеанс 1
BEGIN;
UPDATE row_demo SET v=v+1 WHERE id=1;      
```
```sql
-- Сеанс 2
BEGIN;
UPDATE row_demo SET v=v+1 WHERE id=1;      
```

**Фрагменты вывода:** 

**Задача 1:**
```text
BEGIN

UPDATE
```
```text
BEGIN
```
```text
BEGIN
```
```text

```
```text
  pid   |   locktype    |       mode       | granted |            rel            | transactionid | page | tuple 
--------+---------------+------------------+---------+---------------------------+---------------+------+-------
 141471 | transactionid | ShareLock        | f       |                           |        366378 |      |      
 169532 | tuple         | ExclusiveLock    | f       | row_demo                  |               |    0 |     1
 104958 | relation      | AccessShareLock  | t       | pg_database               |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_authid_oid_index       |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_database_oid_index     |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_database_datname_index |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_authid_rolname_index   |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_locks                  |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_stat_activity          |               |      |      
 104958 | relation      | AccessShareLock  | t       | pg_authid                 |               |      |      
 169532 | relation      | RowExclusiveLock | t       | row_demo_pkey             |               |      |      
 169532 | relation      | RowExclusiveLock | t       | row_demo                  |               |      |      
 141471 | relation      | RowExclusiveLock | t       | row_demo_pkey             |               |      |      
 141471 | relation      | RowExclusiveLock | t       | row_demo                  |               |      |      
 141471 | relation      | RowExclusiveLock | t       | lock_obj_pkey             |               |      |      
 141471 | relation      | RowExclusiveLock | t       | lock_obj                  |               |      |      
 104958 | relation      | RowExclusiveLock | t       | row_demo_pkey             |               |      |      
 104958 | relation      | RowExclusiveLock | t       | row_demo                  |               |      |      
 104958 | transactionid | ExclusiveLock    | t       |                           |        366378 |      |      
 169532 | transactionid | ExclusiveLock    | t       |                           |        366379 |      |      
 141471 | transactionid | ExclusiveLock    | t       |                           |        366375 |      |      
 141471 | tuple         | ExclusiveLock    | t       | row_demo                  |               |    0 |     1
 104958 | virtualxid    | ExclusiveLock    | t       |                           |               |      |      
 141471 | virtualxid    | ExclusiveLock    | t       |                           |               |      |      
 169532 | virtualxid    | ExclusiveLock    | t       |                           |               |      |      
(25 rows)
```

**Задача 2:**
```text
-- Сеанс 1
TRUNCATE TABLE

INSERT 0 3

BEGIN

UPDATE 1
```
```text
-- Сеанс 2
BEGIN

UPDATE
```
```text
-- Сеанс 3
BEGIN

UPDATE
```
```text
-- Сеанс 3
ERROR:  deadlock detected
DETAIL:  Process 141471 waits for ShareLock on transaction 366392; blocked by process 104958.
Process 104958 waits for ShareLock on transaction 366393; blocked by process 169532.
Process 169532 waits for ShareLock on transaction 366394; blocked by process 141471.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "row_demo"
```
```text
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db LOG:  process 141471 detected deadlock while waiting for ShareLock on transaction 366392 after 100.295 ms
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db DETAIL:  Process holding the lock: 104958. Wait queue: .
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db CONTEXT:  while updating tuple (0,1) in relation "row_demo"
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db STATEMENT:  UPDATE row_demo SET v = v+1 WHERE id = 1;
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db ERROR:  deadlock detected
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db DETAIL:  Process 141471 waits for ShareLock on transaction 366392; blocked by process 104958.
	Process 104958 waits for ShareLock on transaction 366393; blocked by process 169532.
	Process 169532 waits for ShareLock on transaction 366394; blocked by process 141471.
	Process 141471: UPDATE row_demo SET v = v+1 WHERE id = 1;
	Process 104958: UPDATE row_demo SET v = v+1 WHERE id = 2;
	Process 169532: UPDATE row_demo SET v = v+1 WHERE id = 3;
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db HINT:  See server log for query details.
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db CONTEXT:  while updating tuple (0,1) in relation "row_demo"
2025-10-09 18:24:00.121 MSK [141471] student@lab06_db STATEMENT:  UPDATE row_demo SET v = v+1 WHERE id = 1;
2025-10-09 18:24:00.122 MSK [169532] student@lab06_db LOG:  process 169532 acquired ShareLock on transaction 366394 after 12773.110 ms
2025-10-09 18:24:00.122 MSK [169532] student@lab06_db CONTEXT:  while updating tuple (0,3) in relation "row_demo"
2025-10-09 18:24:00.122 MSK [169532] student@lab06_db STATEMENT:  UPDATE row_demo SET v = v+1 WHERE id = 3;
2025-10-09 18:24:00.122 MSK [169532] student@lab06_db LOG:  duration: 12773.389 ms  statement: UPDATE row_demo SET v = v+1 WHERE id = 3;
```

**Задача 3:**
```text
-- Сеанс 1
BEGIN
UPDATE 1
  
```
```text
-- Сеанс 2
BEGIN

```

---

### Часть 4. Блокировки в оперативной памяти
**Выполненные задачи:**   
1.	Используя `pg_buffercache`, убедитился, что открытый курсор удерживает закрепление буфера (`pinning`) для быстрого чтения следующей строки.

2.  Открыл курсор на таблице. Не закрывая его, выполнил `VACUUM` этой таблицы. Определил, будет ли `VACUUM` ожидать освобождения закрепления буфера.

3.	Повторил эксперимент с `VACUUM FREEZE`. Убедился, что в профиле ожиданий процесса VACUUM появилось ожидание снятия закрепления буфера (`buffer pin`).

**Команды:**

**Задача 1:**
```sql
-- Сеанс 1
CREATE TABLE pin_demo(id int primary key, t text);
INSERT INTO pin_demo SELECT g, repeat('x',100) FROM generate_series(1,5000) g;
BEGIN;
DECLARE c CURSOR FOR SELECT * FROM pin_demo ORDER BY id;
FETCH 1 FROM c;
```
```sql
-- Сеанс 2
CREATE EXTENSION pg_buffercache;
WITH me(db) AS (SELECT oid FROM pg_database WHERE datname=current_database())
SELECT bufferid, relblocknumber, pinning_backends AS pinning_pid
FROM pg_buffercache
WHERE reldatabase  = (SELECT db FROM me)
  AND relfilenode  = pg_relation_filenode('pin_demo'::regclass)
  AND relforknumber= 0
  AND pinning_backends IS NOT NULL
  AND pinning_backends <> 0;
```

**Задача 2:**
```sql
-- Сеанс 2
ALTER TABLE pin_demo SET (autovacuum_enabled = off);
VACUUM (VERBOSE) pin_demo;

```
```sql
-- Сеанс 3
SELECT pid, wait_event_type, wait_event, state, query
FROM pg_stat_activity
WHERE query ILIKE 'VACUUM%' AND datname = current_database();
```

**Задача 3:**
```sql
-- Сеанс 1
DROP TABLE pin_demo;
CREATE TABLE pin_demo(id int primary key, t text);
INSERT INTO pin_demo SELECT g, repeat('x',100) FROM generate_series(1,5000) g;
BEGIN;
DECLARE c CURSOR FOR SELECT * FROM pin_demo ORDER BY id;
FETCH 1 FROM c;
```
```sql
-- Сеанс 2
ALTER TABLE pin_demo SET (autovacuum_enabled = off);
VACUUM (VERBOSE, FREEZE) pin_demo;

```
```sql
-- Сеанс 3
SELECT pid, wait_event_type, wait_event, state, query
FROM pg_stat_activity
WHERE query ILIKE 'VACUUM%' AND datname = current_database();
```
```sql
-- Сеанс 1
CLOSE c;
```
```sql
-- Сеанс 3
SELECT pid, wait_event_type, wait_event, state, query
FROM pg_stat_activity
WHERE query ILIKE 'VACUUM%' AND datname = current_database();
```

**Фрагменты вывода:** 

**Задача 1**
```text
CREATE TABLE

INSERT 0 5000

BEGIN

DECLARE CURSOR

 id |                                                  t                                                   
----+------------------------------------------------------------------------------------------------------
  1 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)
```
```text
--Сеанс 2
 bufferid | relblocknumber | pinning_pid 
----------+----------------+-------------
      429 |              0 |           1
(1 row)
```

**Задача 2:**
```text
ALTER TABLE

INFO:  vacuuming "lab06_db.public.pin_demo"
INFO:  finished vacuuming "lab06_db.public.pin_demo": index scans: 0
pages: 0 removed, 87 remain, 2 scanned (2.30% of total)
tuples: 0 removed, 4955 remain, 0 are dead but not yet removable
removable cutoff: 366421, which was 1 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 13 hits, 0 misses, 0 dirtied
WAL usage: 1 records, 0 full page images, 237 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
INFO:  vacuuming "lab06_db.pg_toast.pg_toast_57534"
INFO:  finished vacuuming "lab06_db.pg_toast.pg_toast_57534": index scans: 0
pages: 0 removed, 0 remain, 0 scanned (100.00% of total)
tuples: 0 removed, 0 remain, 0 are dead but not yet removable
removable cutoff: 366421, which was 1 XIDs old when operation ended
frozen: 0 pages from table (100.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (100.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 6 hits, 0 misses, 0 dirtied
WAL usage: 0 records, 0 full page images, 0 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
VACUUM
```
```text
 pid  | wait_event_type | wait_event | state |           query            
------+-----------------+------------+-------+----------------------------
 7019 | Client          | ClientRead | idle  | VACUUM (VERBOSE) pin_demo;
(1 row)
```

**Задача 3:**
```text
INFO:  aggressively vacuuming "lab06_db.public.pin_demo"
```
```text
 pid  | wait_event_type | wait_event | state  |               query                
------+-----------------+------------+--------+------------------------------------
 7019 | BufferPin       | BufferPin  | active | VACUUM (VERBOSE, FREEZE) pin_demo;
```
```text
-- Сеанс 1
CLOSE CURSOR
```
```text
-- Сеанс 2
INFO:  finished vacuuming "lab06_db.public.pin_demo": index scans: 0
pages: 0 removed, 87 remain, 87 scanned (100.00% of total)
tuples: 0 removed, 5000 remain, 0 are dead but not yet removable
removable cutoff: 366428, which was 0 XIDs old when operation ended
new relfrozenxid: 366428, which is 2 XIDs ahead of previous value
frozen: 87 pages from table (100.00% of total) had 5000 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 195 hits, 0 misses, 3 dirtied
WAL usage: 177 records, 3 full page images, 21471 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 89.75 s
INFO:  aggressively vacuuming "lab06_db.pg_toast.pg_toast_57541"
INFO:  finished vacuuming "lab06_db.pg_toast.pg_toast_57541": index scans: 0
pages: 0 removed, 0 remain, 0 scanned (100.00% of total)
tuples: 0 removed, 0 remain, 0 are dead but not yet removable
removable cutoff: 366428, which was 0 XIDs old when operation ended
new relfrozenxid: 366428, which is 2 XIDs ahead of previous value
frozen: 0 pages from table (100.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (100.00% of total) had 0 dead item identifiers removed
avg read rate: 56.205 MB/s, avg write rate: 0.000 MB/s
buffer usage: 19 hits, 1 misses, 0 dirtied
WAL usage: 1 records, 0 full page images, 188 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
VACUUM
```
```text
 pid  | wait_event_type | wait_event | state |               query                
------+-----------------+------------+-------+------------------------------------
 7019 | Client          | ClientRead | idle  | VACUUM (VERBOSE, FREEZE) pin_demo;
(1 row)
```

## Результаты выполнения

**1. Мониторинг активности и статистики**
В результате экспериментов с таблицей `monitor_test` подтверждено, что системные представления `pg_stat_all_tables` и `pg_stat_statements` позволяют отслеживать как активность DML-операций, так и историю выполнения запросов. После вставки и удаления строк корректно увеличиваются счётчики `n_tup_ins` и `n_tup_del`, а выполнение `VACUUM` обнуляет `n_dead_tup`, демонстрируя актуализацию статистики.  
Подключение расширения `pg_stat_statements` дало возможность собирать статистику по времени планирования и выполнения запросов, количеству вызовов и возвращаемых строк, что обеспечивает инструментальный контроль за производительностью.

**2. Анализ взаимоблокировок**
Была воспроизведена ситуация классического взаимного ожидания между двумя транзакциями (`UPDATE` двух строк в разном порядке). В журнале сообщений сервера зафиксированы строки:
Проведён анализ: причина — перекрёстное ожидание блокировок строк в одной таблице. PostgreSQL корректно обнаруживает цикл зависимостей и прерывает одну из транзакций, предотвращая зависание системы.  
Дополнительно были выполнены опыты с тремя транзакциями, демонстрирующие построение «треугольного» графа ожиданий (A → B → C → A). Логи показали, что сервер детально регистрирует идентификаторы транзакций и соответствующие `pid`, что позволяет по журналу точно реконструировать структуру deadlock-графа.

**3. Поведение блокировок при чтении и изоляции**
На уровне `Read Committed` при обычном `SELECT` фиксируются блокировки типа `AccessShareLock` на таблице и индексе. Это минимальные блокировки, защищающие структуру от DDL-операций, но не мешающие конкурентным чтениям и модификациям.  
В режиме `SERIALIZABLE` были зафиксированы предикатные блокировки, что привело к повышению уровня ограничений и вызвало ошибку сериализации при попытке параллельной вставки в пересекающийся диапазон (`could not serialize access due to read/write dependencies`).  
Этот эксперимент наглядно показал механизм эскалации предикатных блокировок и алгоритм детектирования фантомных чтений.v

**4. Отслеживание долгих ожиданий и логирование**
Параметры `log_lock_waits = on` и `deadlock_timeout = 100ms` позволили зафиксировать в логах сообщения о длительных ожиданиях. Подтвердили работу встроенного механизма мониторинга блокировок и дали возможность количественно оценить время ожидания ресурса.

**5. Анализ блокировок строк**
В ходе экспериментов с тремя конкурентными транзакциями установлено:
- Первая транзакция удерживает `ExclusiveLock` на свою строку;
- Вторая получает `ShareLock` на транзакцию первой и `ExclusiveLock` на строку;
- Третья — ожидает снятия блокировки с той же строки (`f` в поле `granted`).  
Это демонстрирует цепочку зависимостей и работу механизма `tuple-level locking`.  
При попытке параллельного обновления одних и тех же строк PostgreSQL гарантирует сериализацию, не допуская потери данных.

**6. Взаимоблокировки трёх транзакций**
В ходе эксперимента 1→2→3→1 система выявила цикл зависимостей и инициировала отмену одной транзакции с подробным логом. Этот тест показал внутренний алгоритм обхода графа ожиданий, используемый процессом `deadlock detector`, который срабатывает при превышении таймаута `deadlock_timeout`.

**7. Блокировки в оперативной памяти**
Используя расширение `pg_buffercache`, подтверждено, что открытые курсоры удерживают закрепление буферов (`BufferPin`), предотвращая их очистку. При выполнении `VACUUM` без закрытия курсора процесс ожидал снятия `pin`, что подтверждено через `pg_stat_activity` (`wait_event_type = BufferPin`). После закрытия курсора `VACUUM` успешно завершился.

## Выводы
1. Изучил систему блокировок в PostgreSQL и методы мониторинга активности сервера. 
2. Получил практические навыки анализа статистики, диагностики блокировок и взаимоблокировок, использования инструментов мониторинга.
